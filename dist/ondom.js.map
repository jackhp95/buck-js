{
  "version": 3,
  "sources": ["../src/graph.js", "../src/utils.js", "../src/ondom.js"],
  "sourcesContent": ["const Graph = (entries = []) => {\n  const err = (...xs) => console.warn(...xs);\n  const g = new Map(entries);\n  return {\n    clear: () => g.clear(),\n    delete: (k) => {\n      if (g.has(k)) {\n        const vs = g.get(k);\n        vs.forEach((v) => {\n          const ks = g.get(v);\n          ks.delete(k);\n          if (!ks.size) {\n            g.delete(v);\n          }\n        });\n        g.delete(k);\n        return vs;\n      }\n    },\n    remove: (k) => (v) => {\n      if (g.has(k)) {\n        const vs = g.get(k);\n        vs.delete(v);\n        if (!vs.size) {\n          g.delete(k);\n        }\n      }\n      if (g.has(v)) {\n        const ks = g.get(v);\n        ks.delete(k);\n        if (!ks.size) {\n          g.delete(v);\n        }\n      }\n    },\n    size: () => g.size,\n    has: (k) => {\n      if (g.has(k)) {\n        const vs = g.get(k);\n        // functions are truthy,\n        // this allows us to have optional edge checking via closure.\n        return (v) => new Set(vs).has(v);\n      }\n      return false;\n    },\n    // spread operator prevents mutation to graph internals\n    get: (x) => (g.has(x) ? new Set(g.get(x)) : undefined),\n    set: (k) => (v) => {\n      if (g.has(k)) {\n        g.get(k).add(v);\n      } else {\n        g.set(k, new Set([v]));\n      }\n      if (g.has(v)) {\n        g.get(v).add(k);\n      } else {\n        g.set(v, new Set([k]));\n      }\n    },\n    nodes: () => new Set(g.keys()),\n    edges: () => {\n      const e = [];\n      g.forEach((vs, k) => vs.forEach((v) => e.push([k, v])));\n      return e;\n    },\n    tidy: () => {\n      g.entries().map(([k, vs]) => {\n        loop((v) => {\n          if (g.has(v)) {\n            if (!g.get(v).has(k)) {\n              err(\"non-bidirectional | exists in set, not in map: \", k);\n            }\n          } else {\n            err(\"non-bidirectional | exists in map, not in set: \", v);\n          }\n        })(vs);\n      });\n    },\n  };\n};\n\nexport { Graph };\n", "const loop = (fn) => (xs) => {\n  for (const x of xs) {\n    fn(x);\n  }\n};\nconst log = (x) => (console.log(x), x);\nconst QSA = (sel, el = document) => el.querySelectorAll(sel);\nconst QS = (sel, el = document) => el.querySelector(sel);\nconst asEl = (node) => (node.tagName ? node : node.parentElement);\nconst invoke = (fn, ...args) => fn(...args);\nconst noop = () => {};\nconst identity = (x) => x;\nconst kebabToCamel = (str) => str.replace(/-./g, (m) => m.toUpperCase()[1]);\nconst camelToKebab = (str) =>\n  str.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\n\nconst falseRE = /^\\s*|false|f|0|\\s*$/i;\nconst asBool = (any) => (typeof any === \"string\" ? !falseRE.test(any) : !!any);\nconst equals = (a, b) => {\n  if (a === b) return true;\n\n  if (a instanceof Date && b instanceof Date)\n    return a.getTime() === b.getTime();\n\n  if (!a || !b || (typeof a !== \"object\" && typeof b !== \"object\"))\n    return a === b;\n\n  if (a.prototype !== b.prototype) return false;\n\n  const keys = Object.keys(a);\n  if (keys.length !== Object.keys(b).length) return false;\n\n  return keys.every((k) => equals(a[k], b[k]));\n};\nconst dotNoteRE = /^[\\w|\\$|\\_][\\w|\\$|\\_|0-9]+/;\nconst dotOrBox = (v) =>\n  dotNoteRE.test(v) ? `${v}.` : `[${v.replaceAll('\"', '\\\\\"')}].`;\n\nconst flattenObject = (obj, c) => {\n  const { prefix, join } = Object.assign({ prefix: \"\", join: dotOrBox }, c);\n  return Object.keys(obj).reduce((acc, k) => {\n    const pre = prefix.length ? `${prefix}` : \"\";\n    if (\n      typeof obj[k] === \"object\" &&\n      obj[k] !== null &&\n      Object.keys(obj[k]).length > 0\n    )\n      Object.assign(\n        acc,\n        flattenObject(obj[k], { prefix: pre + join(k), join })\n      );\n    else acc[pre + k] = obj[k];\n    return acc;\n  }, {});\n};\n\nconst maybe =\n  (mapFn, withDefault = noop) =>\n  (...args) => {\n    try {\n      return mapFn(...args);\n    } catch (e) {\n      return withDefault(e, ...args);\n    }\n  };\nconst perf =\n  (fn, _name) =>\n  async (...args) => {\n    const name = _name || fn.name;\n    performance.mark(\"a\");\n    const result = await Promise.resolve(fn(...args));\n    performance.mark(\"b\");\n    performance.measure(name, \"a\", \"b\");\n    loop(console.log)(performance.getEntriesByName(name, \"measure\"));\n    return result;\n  };\nconst documentPositionComparator = (a, b) => {\n  if (a === b) {\n    return 0;\n  }\n  var position = a.compareDocumentPosition(b);\n  if (\n    position & Node.DOCUMENT_POSITION_FOLLOWING ||\n    position & Node.DOCUMENT_POSITION_CONTAINED_BY\n  ) {\n    return -1;\n  } else if (\n    position & Node.DOCUMENT_POSITION_PRECEDING ||\n    position & Node.DOCUMENT_POSITION_CONTAINS\n  ) {\n    return 1;\n  } else {\n    return 0;\n  }\n};\nconst sortEls = (els) =>\n  (\"sort\" in els ? els : [...els]).sort(documentPositionComparator);\n\nconst attrPatternMatch = {\n  1: (el) => {\n    const o = {};\n    loop((a) => {\n      o[a.name] = a.value;\n    })(el.attributes);\n    return o;\n  },\n  2: (el, get) => el.getAttribute(get),\n  3: (el, get, set) => el.setAttribute(get, set),\n};\n\nconst inlineFunction =\n  (attrName, ...argNames) =>\n  (el, ...argValues) => {\n    if (!(attrName in el)) {\n      const fn = Function(...argNames, el.getAttribute(attrName)).bind(el);\n      el[attrName] = fn;\n    }\n    return el[attrName](...argValues);\n  };\nconst cleanPathRE = /^[\\.\\[]/;\nconst inlinePath = (attrName, obj) => (el) => {\n  if (!(attrName in el)) {\n    const path = el.getAttribute(attrName);\n    const cleanPath = cleanPathRE.test(path) ? path : \".\" + path;\n\n    // store the callback function to make non-ref values reactive;\n    el[attrName] = Function(\n      \"maybe\",\n      \"obj\",\n      `return maybe((...a) => {\n          if (a.length) {\n            const [value] = a;\n            obj${cleanPath} = value;\n          }\n          return obj${cleanPath};\n        }, () => console.error(\"failed to resolve ${path}\"));`\n    )(maybe, obj);\n  }\n  return el[attrName];\n};\n\nconst resolve = {\n  event: (attrName) => (event) =>\n    inlineFunction(attrName, \"event\")(event.target, event),\n  entry: (attrName) => (entry) =>\n    inlineFunction(attrName, \"entry\")(entry.target, entry),\n  js: inlineFunction,\n  path: inlinePath,\n};\n\nconst attr = (...args) => attrPatternMatch[args.length](args);\nconst cssPatternMatch = {\n  2: (el, key) => getComputedStyle(el).getPropertyValue(key),\n  3: (el, key, value) => {\n    el.style[key] = value;\n  },\n};\nconst css = (...args) => cssPatternMatch[args.length](...args);\n\nexport {\n  loop,\n  log,\n  QSA,\n  QS,\n  resolve,\n  asEl,\n  sortEls,\n  css,\n  invoke,\n  equals,\n  flattenObject,\n  perf,\n  attr,\n  maybe,\n  noop,\n  identity,\n  falseRE,\n  asBool,\n  kebabToCamel,\n  camelToKebab,\n};\n", "import { Graph } from \"./graph.js\";\nimport { log, loop, QSA, asEl, sortEls, invoke } from \"./utils.js\";\n\nconst onDom = async (c) => {\n  // STATE\n  const config = {\n    root: c.root || document,\n    scheduleInit:\n      c.scheduleInit ||\n      ((fn) =>\n        addEventListener(\"DOMContentLoaded\", fn, {\n          once: true,\n        })),\n    scheduleQueue: c.scheduleQueue || ((fn) => fn()),\n  };\n  const observerConfig = {\n    attributes: true,\n    attributeOldValue: true,\n    childList: true,\n    subtree: true,\n  };\n  const state = {\n    // state\n    graph: Graph(), // all known relevant elements\n    match: new Set(), // needs to rematch plugins because element moved/mutated\n    query: new Set(), // needs to query\n    queue: new Set(), // contents updated\n    after: new Set(), // contents updated\n    plugins: new Set(c.plugins || []),\n    allSelect: \"\",\n  };\n  // SETUP\n\n  const refreshAllSelect = () => {\n    state.allSelect = [...state.plugins].map((p) => p.select).join();\n  };\n  const clearRuntime = () => {\n    state.match.clear();\n    state.query.clear();\n    state.queue.clear();\n    state.after.clear();\n  };\n  const deleteFromGraph = (el) => () => {\n    if (!el.isConnected) {\n      loop((x) => state.graph.delete(x))(QSA(\"*\", el));\n      state.graph.delete(el);\n    }\n  };\n  const runUpdate = (el) => {\n    const plugins = state.graph.get(el);\n    if (!plugins) return;\n    loop((p) => p.update(el))(plugins);\n    // remove element from graph if it doesn't exist after the update.\n    state.after.add(deleteFromGraph(el));\n  };\n  const queueAncestors = ({ parentElement }) => {\n    if (!parentElement || state.queue.has(parentElement)) return;\n    queueAncestors(parentElement);\n    if (state.graph.has(parentElement)) {\n      state.queue.add(parentElement);\n    }\n  };\n  const maybeEdge = (el) => (p) => {\n    const matches = el.matches(p.select);\n    const hasEdge = state.graph.has(p, el);\n    if (hasEdge !== matches) {\n      matches\n        ? state.graph.set(p)(el)\n        : // allows non-matching elements to run one last time to clean-up.\n          state.after.add(() => {\n            state.graph.remove(p)(el);\n          });\n    }\n    if (hasEdge || matches) {\n      state.queue.add(el);\n    }\n  };\n  const matchElement = (el) => [...state.plugins].map(maybeEdge(el));\n  const queryElement = (el) => {\n    // self matches\n    (el.matches(state.allSelect) || state.graph.has(el)) && state.match.add(el);\n    // child matches\n    // finds current matches\n    loop((x) => state.match.add(x))(QSA(state.allSelect, el));\n    // finds previous matches\n    loop((x) => state.graph.has(x) && state.match.add(x))(QSA(\"*\", el));\n  };\n  const onQueue = () => {\n    loop(queryElement)(state.query);\n    loop(matchElement)(state.match);\n    loop(queueAncestors)(state.queue);\n    // console.log(state.queue);\n    loop(runUpdate)(sortEls(state.queue));\n    loop(invoke)(state.after);\n    clearRuntime();\n  };\n  const addElementsToQuery = loop((n) => {\n    const el = asEl(n);\n    el && state.query.add(el);\n  });\n  const onMutationRecord = (mr) => {\n    if (mr.type === \"attributes\") {\n      state.match.add(asEl(mr.target));\n      // delete the custom defined property which corresponds to the changed attribute\n      if (!(mr.attributeName in Object.getPrototypeOf(mr.target))) {\n        delete mr.target[mr.attributeName];\n      }\n    }\n    mr.addedNodes.length && addElementsToQuery(mr.addedNodes);\n    mr.removedNodes.length && addElementsToQuery(mr.removedNodes);\n    state.match.add(asEl(mr.target));\n  };\n  const onMutationRecords = (mrs) => {\n    if (!state.allSelect) return;\n    loop(onMutationRecord)(mrs);\n    config.scheduleQueue(onQueue);\n  };\n  const observer = new MutationObserver(onMutationRecords);\n  const initElement = (p) => (el) => {\n    state.graph.set(p)(el);\n    p.update(el);\n  };\n  const initPlugin = (p) => p.select && loop(initElement(p))(QSA(p.select, config.root));\n\n  // API\n  const returnAPI = () => {\n    const MAIN_FUNCTION = (x) => [...state.graph.get(x)];\n    const METHODS = {\n      add: (p) => {\n        state.plugins.add(p);\n        initPlugin(p);\n      },\n      clear: () => {\n        clearRuntime();\n        state.graph.clear();\n      },\n      delete: (p) => {\n        state.plugins.delete(p);\n        state.graph.delete(p);\n      },\n      plugins: () => [...state.plugins],\n      has: (p) => state.graph.has(p),\n    };\n    const API = Object.assign(MAIN_FUNCTION, METHODS);\n    return c.debug ? Object.assign(API, { debug: state }) : API;\n  };\n\n  const initDOM = async (resolve) => {\n    loop(initPlugin)(state.plugins);\n    refreshAllSelect();\n    observer.observe(config.root, observerConfig);\n    resolve(returnAPI());\n  };\n  // Initialize\n  return new Promise((r) => config.scheduleInit(() => initDOM(r)));\n};\n\nexport { onDom };\n"],
  "mappings": "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",
  "names": []
}
