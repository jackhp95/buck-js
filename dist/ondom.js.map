{
  "version": 3,
  "sources": ["../src/graph.js", "../src/utils.js", "../src/ondom.js"],
  "sourcesContent": ["const Graph = (entries = []) => {\n  const err = (...xs) => console.warn(...xs);\n  const g = new Map(entries);\n  return {\n    clear: () => g.clear(),\n    delete: (k) => {\n      if (g.has(k)) {\n        const vs = g.get(k);\n        vs.forEach((v) => {\n          const ks = g.get(v);\n          ks.delete(k);\n          if (!ks.size) {\n            g.delete(v);\n          }\n        });\n        g.delete(k);\n        return vs;\n      }\n    },\n    remove: (k) => (v) => {\n      if (g.has(k)) {\n        const vs = g.get(k);\n        vs.delete(v);\n        if (!vs.size) {\n          g.delete(k);\n        }\n      }\n      if (g.has(v)) {\n        const ks = g.get(v);\n        ks.delete(k);\n        if (!ks.size) {\n          g.delete(v);\n        }\n      }\n    },\n    size: () => g.size,\n    has: (k) => {\n      if (g.has(k)) {\n        const vs = g.get(k);\n        // functions are truthy,\n        // this allows us to have optional edge checking via closure.\n        return (v) => new Set(vs).has(v);\n      }\n      return false;\n    },\n    // spread operator prevents mutation to graph internals\n    get: (x) => (g.has(x) ? new Set(g.get(x)) : undefined),\n    set: (k) => (v) => {\n      if (g.has(k)) {\n        g.get(k).add(v);\n      } else {\n        g.set(k, new Set([v]));\n      }\n      if (g.has(v)) {\n        g.get(v).add(k);\n      } else {\n        g.set(v, new Set([k]));\n      }\n    },\n    nodes: () => new Set(g.keys()),\n    edges: () => {\n      const e = [];\n      g.forEach((vs, k) => vs.forEach((v) => e.push([k, v])));\n      return e;\n    },\n    tidy: () => {\n      g.entries().map(([k, vs]) => {\n        loop((v) => {\n          if (g.has(v)) {\n            if (!g.get(v).has(k)) {\n              err(\"non-bidirectional | exists in set, not in map: \", k);\n            }\n          } else {\n            err(\"non-bidirectional | exists in map, not in set: \", v);\n          }\n        })(vs);\n      });\n    },\n  };\n};\n\nexport { Graph };\n", "const loop = (fn) => (xs) => {\n  for (const x of xs) {\n    fn(x);\n  }\n};\nconst log = (x) => (console.log(x), x);\nconst QSA = (sel, el = document) => el.querySelectorAll(sel);\nconst asEl = (node) => (node.tagName ? node : node.parentElement);\nconst invoke = (fn, ...args) => fn(...args);\nconst perf = (fn, name) => async (...args) => {\n  performance.mark(\"a\");\n  const result = (typeof fn?.then === 'function') ? (await fn(...args)) : fn(...args);\n  performance.mark(\"b\");\n  performance.measure(name || fn.name, \"a\", \"b\");\n  loop(console.log)(performance.getEntriesByType(\"measure\"));\n  return result;\n};\nconst documentPositionComparator = (a, b) => {\n  if (a === b) {\n    return 0;\n  }\n  var position = a.compareDocumentPosition(b);\n  if (\n    position & Node.DOCUMENT_POSITION_FOLLOWING ||\n    position & Node.DOCUMENT_POSITION_CONTAINED_BY\n  ) {\n    return -1;\n  } else if (\n    position & Node.DOCUMENT_POSITION_PRECEDING ||\n    position & Node.DOCUMENT_POSITION_CONTAINS\n  ) {\n    return 1;\n  } else {\n    return 0;\n  }\n};\nconst sortEls = (els) =>\n  (\"sort\" in els ? els : [...els]).sort(documentPositionComparator);\n\nexport { loop, log, QSA, asEl, sortEls, invoke, perf };\n", "import { Graph } from \"./graph.js\";\nimport { log, loop, QSA, asEl, sortEls, invoke } from \"./utils.js\";\n\nconst onDom = async (c) => {\n  // STATE\n  const config = {\n    root: c.root || document,\n    scheduleInit:\n      c.scheduleInit ||\n      ((fn) =>\n        addEventListener(\"DOMContentLoaded\", fn, {\n          once: true,\n        })),\n    scheduleQueue: c.scheduleQueue || ((fn) => fn()),\n  };\n  const observerConfig = {\n    attributes: true,\n    attributeOldValue: true,\n    childList: true,\n    subtree: true,\n  };\n  const state = {\n    // state\n    graph: Graph(), // all known relevant elements\n    match: new Set(), // needs to rematch plugins because element moved/mutated\n    query: new Set(), // needs to query\n    queue: new Set(), // contents updated\n    after: new Set(), // contents updated\n    plugins: new Set(c.plugins || []),\n    allSelect: \"*\",\n  };\n  // SETUP\n\n  const refreshAllSelect = () => {\n    state.allSelect = [...state.plugins].map((p) => p.select).join();\n  };\n  const clearRuntime = () => {\n    state.match.clear();\n    state.query.clear();\n    state.queue.clear();\n    state.after.clear();\n  };\n  const deleteFromGraph = (el) => () => {\n    if (!el.isConnected) {\n      loop((x) => state.graph.delete(x))(QSA(\"*\", el));\n      state.graph.delete(el);\n    }\n  };\n  const runUpdate = (el) => {\n    const plugins = state.graph.get(el);\n    if (!plugins) return;\n    loop((p) => p.update(el))(plugins);\n    // remove element from graph if it doesn't exist after the update.\n    state.after.add(deleteFromGraph(el));\n  };\n  const queueAncestors = ({ parentElement }) => {\n    if (!parentElement || state.queue.has(parentElement)) return;\n    queueAncestors(parentElement);\n    if (state.graph.has(parentElement)) {\n      state.queue.add(parentElement);\n    }\n  };\n  const maybeEdge = (el) => (p) => {\n    const matches = el.matches(p.select);\n    const hasEdge = state.graph.has(p, el);\n    if (hasEdge !== matches) {\n      matches\n        ? state.graph.set(p)(el)\n        : // allows non-matching elements to run one last time to clean-up.\n          state.after.add(() => {\n            state.graph.remove(p)(el);\n          });\n    }\n    if (hasEdge || matches) {\n      state.queue.add(el);\n    }\n  };\n  const matchElement = (el) => [...state.plugins].map(maybeEdge(el));\n  const queryElement = (el) => {\n    // self matches\n    (el.matches(state.allSelect) || state.graph.has(el)) && state.match.add(el);\n    // child matches\n    // finds current matches\n    loop((x) => state.match.add(x))(QSA(state.allSelect, el));\n    // finds previous matches\n    loop((x) => state.graph.has(x) && state.match.add(x))(QSA(\"*\", el));\n  };\n  const onQueue = () => {\n    loop(queryElement)(state.query);\n    loop(matchElement)(state.match);\n    loop(queueAncestors)(state.queue);\n    loop(runUpdate)(sortEls(state.queue));\n    loop(invoke)(state.after);\n    clearRuntime();\n  };\n  const addElementsToQuery = loop((n) => {\n    const el = asEl(n);\n    el && state.query.add(el);\n  });\n  const onMutationRecord = (mr) => {\n    mr.type === \"attributes\" && state.match.add(asEl(mr.target));\n    mr.addedNodes.length && addElementsToQuery(mr.addedNodes);\n    mr.removedNodes.length && addElementsToQuery(mr.removedNodes);\n    state.match.add(asEl(mr.target));\n  };\n  const onMutationRecords = (mrs) => {\n    loop(onMutationRecord)(mrs);\n    config.scheduleQueue(onQueue);\n  };\n  const observer = new MutationObserver(onMutationRecords);\n  const initElement = (p) => (el) => {\n    state.graph.set(p)(el);\n    p.update(el);\n  };\n  const initPlugin = (p) => loop(initElement(p))(QSA(p.select, config.root));\n\n  // API\n  const returnAPI = () => {\n    const MAIN_FUNCTION = (x) => [...state.graph.get(x)];\n    const METHODS = {\n      add: (p) => {\n        state.plugins.add(p);\n        initPlugin(p);\n      },\n      clear: () => {\n        clearRuntime();\n        state.graph.clear();\n      },\n      delete: (p) => {\n        state.plugins.delete(p);\n        state.graph.delete(p);\n      },\n      has: (p) => state.graph.has(p),\n    };\n    const API = Object.assign(MAIN_FUNCTION, METHODS);\n    return c.debug ? Object.assign(API, { debug: state }) : API;\n  }\n\n  const initDOM = async (resolve) => {\n    loop(initPlugin)(state.plugins);\n    refreshAllSelect();\n    observer.observe(config.root, observerConfig);\n    resolve(returnAPI());\n  };\n  // Initialize\n  return new Promise((r) => config.scheduleInit(() => initDOM(r)));\n};\n\nexport { onDom };\n"],
  "mappings": "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",
  "names": []
}
