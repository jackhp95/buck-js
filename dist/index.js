var E=(t=[])=>{let s=(...e)=>console.warn(...e),n=new Map(t);return{clear:()=>n.clear(),delete:e=>{if(n.has(e)){let r=n.get(e);return r.forEach(c=>{let u=n.get(c);u.delete(e),u.size||n.delete(c)}),n.delete(e),r}},remove:e=>r=>{if(n.has(e)){let c=n.get(e);c.delete(r),c.size||n.delete(e)}if(n.has(r)){let c=n.get(r);c.delete(e),c.size||n.delete(r)}},size:()=>n.size,has:e=>{if(n.has(e)){let r=n.get(e);return c=>new Set(r).has(c)}return!1},get:e=>n.has(e)?new Set(n.get(e)):void 0,set:e=>r=>{n.has(e)?n.get(e).add(r):n.set(e,new Set([r])),n.has(r)?n.get(r).add(e):n.set(r,new Set([e]))},nodes:()=>new Set(n.keys()),edges:()=>{let e=[];return n.forEach((r,c)=>r.forEach(u=>e.push([c,u]))),e},tidy:()=>{n.entries().map(([e,r])=>{loop(c=>{n.has(c)?n.get(c).has(e)||s("non-bidirectional | exists in set, not in map: ",e):s("non-bidirectional | exists in map, not in set: ",c)})(r)})}}};var i=t=>s=>{for(let n of s)t(n)},U=t=>(console.log(t),t),b=(t,s=document)=>s.querySelectorAll(t),z=(t,s=document)=>s.querySelector(t),S=t=>t.tagName?t:t.parentElement,A=(t,...s)=>t(...s),P=()=>{},G=t=>t,L=t=>t.replace(/-./g,s=>s.toUpperCase()[1]),R=t=>t.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase();var q=(t,s=P)=>(...n)=>{try{return t(...n)}catch(e){return s(e,...n)}},B=(t,s)=>async(...n)=>{let e=s||t.name;performance.mark("a");let r=await Promise.resolve(t(...n));return performance.mark("b"),performance.measure(e,"a","b"),i(console.log)(performance.getEntriesByName(e,"measure")),r},k=(t,s)=>{if(t===s)return 0;var n=t.compareDocumentPosition(s);return n&Node.DOCUMENT_POSITION_FOLLOWING||n&Node.DOCUMENT_POSITION_CONTAINED_BY?-1:n&Node.DOCUMENT_POSITION_PRECEDING||n&Node.DOCUMENT_POSITION_CONTAINS?1:0},M=t=>("sort"in t?t:[...t]).sort(k),H={1:t=>{let s={};return i(n=>{s[n.name]=n.value})(t.attributes),s},2:(t,s)=>t.getAttribute(s),3:(t,s,n)=>t.setAttribute(s,n)},K=(...t)=>H[t.length](t),T=(t,...s)=>(n,...e)=>{if(!(t in n)){let r=Function(...s,n.getAttribute(t)).bind(n);n[t]=r}return n[t](...e)},V=(t,s)=>n=>{if(!(t in n)){let e=n.getAttribute(t),r=/^[\.\[]/.test(e)?e:"."+e;n[t]=Function("maybe","obj",`return maybe((...a) => {
          if (a.length) {
            const [value] = a;
            obj${r} = value;
          }
          return obj${r};
        });`)(q,s)}return n[t]},W={event:t=>s=>T(t,"event")(s.target,s),entry:t=>s=>T(t,"entry")(s.target,s),js:T,resolve:V},Y=Object.assign(K,W),Z={2:(t,s)=>getComputedStyle(t).getPropertyValue(s),3:(t,s,n)=>{t.style[s]=n}},J=(...t)=>Z[t.length](...t);var X=async t=>{let s={root:t.root||document,scheduleInit:t.scheduleInit||(o=>addEventListener("DOMContentLoaded",o,{once:!0})),scheduleQueue:t.scheduleQueue||(o=>o())},n={attributes:!0,attributeOldValue:!0,childList:!0,subtree:!0},e={graph:E(),match:new Set,query:new Set,queue:new Set,after:new Set,plugins:new Set(t.plugins||[]),allSelect:""},r=()=>{e.allSelect=[...e.plugins].map(o=>o.select).join()},c=()=>{e.match.clear(),e.query.clear(),e.queue.clear(),e.after.clear()},u=o=>()=>{o.isConnected||(i(a=>e.graph.delete(a))(b("*",o)),e.graph.delete(o))},O=o=>{let a=e.graph.get(o);!a||(i(p=>p.update(o))(a),e.after.add(u(o)))},d=({parentElement:o})=>{!o||e.queue.has(o)||(d(o),e.graph.has(o)&&e.queue.add(o))},y=o=>a=>{let p=o.matches(a.select),l=e.graph.has(a,o);l!==p&&(p?e.graph.set(a)(o):e.after.add(()=>{e.graph.remove(a)(o)})),(l||p)&&e.queue.add(o)},g=o=>[...e.plugins].map(y(o)),f=o=>{(o.matches(e.allSelect)||e.graph.has(o))&&e.match.add(o),i(a=>e.match.add(a))(b(e.allSelect,o)),i(a=>e.graph.has(a)&&e.match.add(a))(b("*",o))},m=()=>{i(f)(e.query),i(g)(e.match),i(d)(e.queue),i(O)(M(e.queue)),i(A)(e.after),c()},I=i(o=>{let a=S(o);a&&e.query.add(a)}),x=o=>{o.type==="attributes"&&(e.match.add(S(o.target)),o.attributeName in Object.getPrototypeOf(o.target)||delete o.target[o.attributeName]),o.addedNodes.length&&I(o.addedNodes),o.removedNodes.length&&I(o.removedNodes),e.match.add(S(o.target))},D=o=>{!e.allSelect||(i(x)(o),s.scheduleQueue(m))},v=new MutationObserver(D),_=o=>a=>{e.graph.set(o)(a),o.update(a)},C=o=>o.select&&i(_(o))(b(o.select,s.root)),Q=()=>{let p=Object.assign(l=>[...e.graph.get(l)],{add:l=>{e.plugins.add(l),C(l)},clear:()=>{c(),e.graph.clear()},delete:l=>{e.plugins.delete(l),e.graph.delete(l)},has:l=>e.graph.has(l)});return t.debug?Object.assign(p,{debug:e}):p},$=async o=>{i(C)(e.plugins),r(),v.observe(s.root,n),o(Q())};return new Promise(o=>s.scheduleInit(()=>$(o)))};var N=(t,s)=>new Proxy(t,{get:(n,e)=>s[e].bind(s),apply:function(n,e,r){return t(...r)}}),w=new Map;function j(t){w.has(t)||w.set(t,new Map);let s=w.get(t);return N(e=>{s.has(e)||s.set(e,new Map);let r=s.get(e);return N((u,O)=>{let d=w.get(e),y=(...g)=>{let f=d.has(u)?O(d.get(u),g):g;d.set(u,f)};return t(e,d),N(y,d)},r)},s)}var ee=(t,s)=>t(()=>{let n=([e,r])=>e(...r);s.entries().forEach(n),s.clear()}),te=j(ee),F=(t,s)=>{t(()=>{let[n,e]=s.entries().next().value;n(...e),s.delete(n),F(t,s)})},ne=j(F),h=t=>s=>{let n={fn:s,canceled:!1};n.cancel=()=>n.canceled=!0,n.throttler=u=>{n.throttle=()=>{n.throttled||(u(()=>n.throttled=!1)(),n.throttled=!0)}};let e={fn:void 0},r=(...u)=>e.fn(...u),c=(...u)=>{n.args=u,n.debounce&&(n.debounce=Date.now()),n.callback=()=>n.fn(...n.args);let O=(g,f)=>[n.canceled,n.throttled,n.debounce&&n.debounce!==g,()=>f(n.callback())].find(m=>m),d=g=>f=>{let m=[O(g,f),n];m.length=t.length,t(...m)};n.throttle&&n.throttle();let y=new Promise(d(n.debounce));return N(r,Object.assign(y,n))};return e.fn=c,c},se=h(t=>t),oe=h(queueMicrotask),re=h(setTimeout),ce=h(requestAnimationFrame),ae=h(t=>requestAnimationFrame(()=>requestAnimationFrame(t))),ie=h(requestIdleCallback),ue=(t=0)=>h(s=>setTimeout(s,t)),le=h((t,s)=>{t(),s.cancel()});export{E as Graph,z as QS,b as QSA,S as asEl,Y as attr,te as batch,R as camelToKebab,J as css,N as extendFunction,G as identity,ie as idle,A as invoke,L as kebabToCamel,U as log,i as loop,q as maybe,ae as next,P as noop,X as onDom,le as once,h as orca,B as perf,ne as recur,M as sortEls,se as sync,re as task,oe as then,ce as tick,ue as wait};
//# sourceMappingURL=index.js.map
