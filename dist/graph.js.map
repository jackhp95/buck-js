{
  "version": 3,
  "sources": ["../src/graph.js"],
  "sourcesContent": ["const Graph = (entries = []) => {\n  const err = (...xs) => console.warn(...xs);\n  const g = new Map(entries);\n  return {\n    clear: () => g.clear(),\n    delete: (k) => {\n      if (g.has(k)) {\n        const vs = g.get(k);\n        vs.forEach((v) => {\n          const ks = g.get(v);\n          ks.delete(k);\n          if (!ks.size) {\n            g.delete(v);\n          }\n        });\n        g.delete(k);\n        return vs;\n      }\n    },\n    remove: (k) => (v) => {\n      if (g.has(k)) {\n        const vs = g.get(k);\n        vs.delete(v);\n        if (!vs.size) {\n          g.delete(k);\n        }\n      }\n      if (g.has(v)) {\n        const ks = g.get(v);\n        ks.delete(k);\n        if (!ks.size) {\n          g.delete(v);\n        }\n      }\n    },\n    size: () => g.size,\n    has: (k) => {\n      if (g.has(k)) {\n        const vs = g.get(k);\n        // functions are truthy,\n        // this allows us to have optional edge checking via closure.\n        return (v) => new Set(vs).has(v);\n      }\n      return false;\n    },\n    // spread operator prevents mutation to graph internals\n    get: (x) => (g.has(x) ? new Set(g.get(x)) : undefined),\n    set: (k) => (v) => {\n      if (g.has(k)) {\n        g.get(k).add(v);\n      } else {\n        g.set(k, new Set([v]));\n      }\n      if (g.has(v)) {\n        g.get(v).add(k);\n      } else {\n        g.set(v, new Set([k]));\n      }\n    },\n    nodes: () => new Set(g.keys()),\n    edges: () => {\n      const e = [];\n      g.forEach((vs, k) => vs.forEach((v) => e.push([k, v])));\n      return e;\n    },\n    tidy: () => {\n      g.entries().map(([k, vs]) => {\n        loop((v) => {\n          if (g.has(v)) {\n            if (!g.get(v).has(k)) {\n              err(\"non-bidirectional | exists in set, not in map: \", k);\n            }\n          } else {\n            err(\"non-bidirectional | exists in map, not in set: \", v);\n          }\n        })(vs);\n      });\n    },\n  };\n};\n\nexport { Graph };\n"],
  "mappings": "AAAA,GAAM,GAAQ,CAAC,EAAU,KAAO,CAC9B,GAAM,GAAM,IAAI,IAAO,QAAQ,KAAK,GAAG,GACjC,EAAI,GAAI,KAAI,GAClB,MAAO,CACL,MAAO,IAAM,EAAE,QACf,OAAQ,AAAC,GAAM,CACb,GAAI,EAAE,IAAI,GAAI,CACZ,GAAM,GAAK,EAAE,IAAI,GACjB,SAAG,QAAQ,AAAC,GAAM,CAChB,GAAM,GAAK,EAAE,IAAI,GACjB,EAAG,OAAO,GACL,EAAG,MACN,EAAE,OAAO,KAGb,EAAE,OAAO,GACF,IAGX,OAAQ,AAAC,GAAM,AAAC,GAAM,CACpB,GAAI,EAAE,IAAI,GAAI,CACZ,GAAM,GAAK,EAAE,IAAI,GACjB,EAAG,OAAO,GACL,EAAG,MACN,EAAE,OAAO,GAGb,GAAI,EAAE,IAAI,GAAI,CACZ,GAAM,GAAK,EAAE,IAAI,GACjB,EAAG,OAAO,GACL,EAAG,MACN,EAAE,OAAO,KAIf,KAAM,IAAM,EAAE,KACd,IAAK,AAAC,GAAM,CACV,GAAI,EAAE,IAAI,GAAI,CACZ,GAAM,GAAK,EAAE,IAAI,GAGjB,MAAO,AAAC,IAAM,GAAI,KAAI,GAAI,IAAI,GAEhC,MAAO,IAGT,IAAK,AAAC,GAAO,EAAE,IAAI,GAAK,GAAI,KAAI,EAAE,IAAI,IAAM,OAC5C,IAAK,AAAC,GAAM,AAAC,GAAM,CACjB,AAAI,EAAE,IAAI,GACR,EAAE,IAAI,GAAG,IAAI,GAEb,EAAE,IAAI,EAAG,GAAI,KAAI,CAAC,KAEpB,AAAI,EAAE,IAAI,GACR,EAAE,IAAI,GAAG,IAAI,GAEb,EAAE,IAAI,EAAG,GAAI,KAAI,CAAC,MAGtB,MAAO,IAAM,GAAI,KAAI,EAAE,QACvB,MAAO,IAAM,CACX,GAAM,GAAI,GACV,SAAE,QAAQ,CAAC,EAAI,IAAM,EAAG,QAAQ,AAAC,GAAM,EAAE,KAAK,CAAC,EAAG,MAC3C,GAET,KAAM,IAAM,CACV,EAAE,UAAU,IAAI,CAAC,CAAC,EAAG,KAAQ,CAC3B,KAAK,AAAC,GAAM,CACV,AAAI,EAAE,IAAI,GACH,EAAE,IAAI,GAAG,IAAI,IAChB,EAAI,kDAAmD,GAGzD,EAAI,kDAAmD,KAExD",
  "names": []
}
