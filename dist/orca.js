var u=(e,n)=>new Proxy(e,{get:(t,o)=>n[o].bind(n),apply:function(t,o,s){return e(...s)}});function p(e){this.rootMap||(this.rootMap=new Map);let n=this.rootMap;n.has(e)||n.set(e,new Map);let t=n.get(e);return u(s=>{t.has(s)||t.set(s,new Map);let i=t.get(s);return u((a,l)=>{let r=n.get(s),b=(...d)=>{let f=r.has(a)?l(r.get(a),d):d;r.set(a,f)};return e(s,r),u(b,r)},i)},t)}var M=(e,n)=>e(()=>{let t=([o,s])=>o(...s);n.entries().forEach(t),n.clear()}),m=p(M),g=(e,n)=>{e(()=>{let[t,o]=n.entries().next().value;t(...o),n.delete(t),g(e,n)})},w=p(g),c=e=>n=>{let t={fn:n,canceled:!1};return t.cancel=()=>t.canceled=!0,t.throttler=o=>{t.throttle=()=>{t.throttled||(o(()=>t.throttled=!1)(),t.throttled=!0)}},function(...o){t.args=o,t.debounce&&(t.debounce=Date.now()),t.callback=()=>t.fn(...t.args);let s=(a,l)=>[t.canceled,t.throttled,t.debounce&&t.debounce!==a,()=>l(t.callback())].find(r=>r),i=a=>l=>{let r=[s(a,l),t];r.length=e.length,e(...r)};t.throttle&&t.throttle();let h=new Promise(i(t.debounce));return u(this,Object.assign(h,t))}},F=c(e=>e),k=c(queueMicrotask),x=c(setTimeout),A=c(requestAnimationFrame),q=c(e=>requestAnimationFrame(()=>requestAnimationFrame(e))),T=c(requestIdleCallback),y=(e=0)=>c(n=>setTimeout(n,e)),P=c((e,n)=>{e(),n.cancel()});export{m as batch,u as extendFunction,T as idle,q as next,P as once,c as orca,w as recur,F as sync,x as task,k as then,A as tick,y as wait};
//# sourceMappingURL=orca.js.map
