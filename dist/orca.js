var d=(e,n)=>new Proxy(e,{get:(t,s)=>n[s].bind(n),apply:function(t,s,o){return e(...o)}}),h=new Map;function b(e){h.has(e)||h.set(e,new Map);let n=h.get(e);return d(s=>{n.has(s)||n.set(s,new Map);let o=n.get(s);return d((c,f)=>{let a=h.get(s),g=(...l)=>{let u=a.has(c)?f(a.get(c),l):l;a.set(c,u)};return e(s,a),d(g,a)},o)},n)}var F=(e,n)=>e(()=>{let t=([s,o])=>s(...o);n.entries().forEach(t),n.clear()}),w=b(F),m=(e,n)=>{e(()=>{let[t,s]=n.entries().next().value;t(...s),n.delete(t),m(e,n)})},x=b(m),r=e=>n=>{let t={fn:n,canceled:!1};t.cancel=()=>t.canceled=!0,t.throttler=c=>{t.throttle=()=>{t.throttled||(c(()=>t.throttled=!1)(),t.throttled=!0)}};let s={fn:void 0},o=(...c)=>s.fn(...c),p=(...c)=>{t.args=c,t.debounce&&(t.debounce=Date.now()),t.callback=()=>t.fn(...t.args);let f=(l,u)=>[t.canceled,t.throttled,t.debounce&&t.debounce!==l,()=>u(t.callback())].find(i=>i),a=l=>u=>{let i=[f(l,u),t];i.length=e.length,e(...i)};t.throttle&&t.throttle();let g=new Promise(a(t.debounce));return d(o,Object.assign(g,t))};return s.fn=p,p},M=r(e=>e),k=r(queueMicrotask),A=r(setTimeout),q=r(requestAnimationFrame),T=r(e=>requestAnimationFrame(()=>requestAnimationFrame(e))),y=r(requestIdleCallback),C=(e=0)=>r(n=>setTimeout(n,e)),P=r((e,n)=>{e(),n.cancel()});export{w as batch,d as extendFunction,y as idle,T as next,P as once,r as orca,x as recur,M as sync,A as task,k as then,q as tick,C as wait};
//# sourceMappingURL=orca.js.map
