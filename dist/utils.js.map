{
  "version": 3,
  "sources": ["../src/utils.js"],
  "sourcesContent": ["const loop = (fn) => (xs) => {\n  for (const x of xs) {\n    fn(x);\n  }\n};\nconst log = (x) => (console.log(x), x);\nconst QSA = (sel, el = document) => el.querySelectorAll(sel);\nconst QS = (sel, el = document) => el.querySelector(sel);\nconst asEl = (node) => (node.tagName ? node : node.parentElement);\nconst invoke = (fn, ...args) => fn(...args);\nconst noop = () => {};\nconst identity = (x) => x;\nconst kebabToCamel = (str) => str.replace(/-./g, (m) => m.toUpperCase()[1]);\nconst camelToKebab = (str) =>\n  str.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\n\nconst falseRE = /^\\s*|false|f|0|\\s*$/i;\nconst asBool = (any) => (typeof any === \"string\" ? !falseRE.test(any) : !!any);\nconst equals = (a, b) => {\n  if (a === b) return true;\n\n  if (a instanceof Date && b instanceof Date)\n    return a.getTime() === b.getTime();\n\n  if (!a || !b || (typeof a !== \"object\" && typeof b !== \"object\"))\n    return a === b;\n\n  if (a.prototype !== b.prototype) return false;\n\n  const keys = Object.keys(a);\n  if (keys.length !== Object.keys(b).length) return false;\n\n  return keys.every((k) => equals(a[k], b[k]));\n};\nconst dotNoteRE = /^[\\w|\\$|\\_][\\w|\\$|\\_|0-9]+/;\nconst dotOrBox = (v) =>\n  dotNoteRE.test(v) ? `${v}.` : `[${v.replaceAll('\"', '\\\\\"')}].`;\n\nconst flattenObject = (obj, c) => {\n  const { prefix, join } = Object.assign({ prefix: \"\", join: dotOrBox }, c);\n  return Object.keys(obj).reduce((acc, k) => {\n    const pre = prefix.length ? `${prefix}` : \"\";\n    if (\n      typeof obj[k] === \"object\" &&\n      obj[k] !== null &&\n      Object.keys(obj[k]).length > 0\n    )\n      Object.assign(\n        acc,\n        flattenObject(obj[k], { prefix: pre + join(k), join })\n      );\n    else acc[pre + k] = obj[k];\n    return acc;\n  }, {});\n};\n\nconst maybe =\n  (mapFn, withDefault = noop) =>\n  (...args) => {\n    try {\n      return mapFn(...args);\n    } catch (e) {\n      return withDefault(e, ...args);\n    }\n  };\nconst perf =\n  (fn, _name) =>\n  async (...args) => {\n    const name = _name || fn.name;\n    performance.mark(\"a\");\n    const result = await Promise.resolve(fn(...args));\n    performance.mark(\"b\");\n    performance.measure(name, \"a\", \"b\");\n    loop(console.log)(performance.getEntriesByName(name, \"measure\"));\n    return result;\n  };\nconst documentPositionComparator = (a, b) => {\n  if (a === b) {\n    return 0;\n  }\n  var position = a.compareDocumentPosition(b);\n  if (\n    position & Node.DOCUMENT_POSITION_FOLLOWING ||\n    position & Node.DOCUMENT_POSITION_CONTAINED_BY\n  ) {\n    return -1;\n  } else if (\n    position & Node.DOCUMENT_POSITION_PRECEDING ||\n    position & Node.DOCUMENT_POSITION_CONTAINS\n  ) {\n    return 1;\n  } else {\n    return 0;\n  }\n};\nconst sortEls = (els) =>\n  (\"sort\" in els ? els : [...els]).sort(documentPositionComparator);\n\nconst attrPatternMatch = {\n  1: (el) => {\n    const o = {};\n    loop((a) => {\n      o[a.name] = a.value;\n    })(el.attributes);\n    return o;\n  },\n  2: (el, get) => el.getAttribute(get),\n  3: (el, get, set) => el.setAttribute(get, set),\n};\n\nconst inlineFunction =\n  (attrName, ...argNames) =>\n  (el, ...argValues) => {\n    if (!(attrName in el)) {\n      const fn = Function(...argNames, el.getAttribute(attrName)).bind(el);\n      el[attrName] = fn;\n    }\n    return el[attrName](...argValues);\n  };\nconst cleanPathRE = /^[\\.\\[]/;\nconst inlinePath = (attrName, obj) => (el) => {\n  if (!(attrName in el)) {\n    const path = el.getAttribute(attrName);\n    const cleanPath = cleanPathRE.test(path) ? path : \".\" + path;\n\n    // store the callback function to make non-ref values reactive;\n    el[attrName] = Function(\n      \"maybe\",\n      \"obj\",\n      `return maybe((...a) => {\n          if (a.length) {\n            const [value] = a;\n            obj${cleanPath} = value;\n          }\n          return obj${cleanPath};\n        }, () => console.error(\"failed to resolve ${path}\"));`\n    )(maybe, obj);\n  }\n  return el[attrName];\n};\n\nconst resolve = {\n  event: (attrName) => (event) =>\n    inlineFunction(attrName, \"event\")(event.target, event),\n  entry: (attrName) => (entry) =>\n    inlineFunction(attrName, \"entry\")(entry.target, entry),\n  js: inlineFunction,\n  path: inlinePath,\n};\n\nconst attr = (...args) => attrPatternMatch[args.length](args);\nconst cssPatternMatch = {\n  2: (el, key) => getComputedStyle(el).getPropertyValue(key),\n  3: (el, key, value) => {\n    el.style[key] = value;\n  },\n};\nconst css = (...args) => cssPatternMatch[args.length](...args);\n\nexport {\n  loop,\n  log,\n  QSA,\n  QS,\n  resolve,\n  asEl,\n  sortEls,\n  css,\n  invoke,\n  equals,\n  flattenObject,\n  perf,\n  attr,\n  maybe,\n  noop,\n  identity,\n  falseRE,\n  asBool,\n  kebabToCamel,\n  camelToKebab,\n};\n"],
  "mappings": "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",
  "names": []
}
