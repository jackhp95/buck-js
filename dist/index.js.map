{
  "version": 3,
  "sources": ["../src/graph.js", "../src/utils.js", "../src/ondom.js", "../src/orca.js"],
  "sourcesContent": ["const Graph = (entries = []) => {\n  const err = (...xs) => console.warn(...xs);\n  const g = new Map(entries);\n  return {\n    clear: () => g.clear(),\n    delete: (k) => {\n      if (g.has(k)) {\n        const vs = g.get(k);\n        vs.forEach((v) => {\n          const ks = g.get(v);\n          ks.delete(k);\n          if (!ks.size) {\n            g.delete(v);\n          }\n        });\n        g.delete(k);\n        return vs;\n      }\n    },\n    remove: (k) => (v) => {\n      if (g.has(k)) {\n        const vs = g.get(k);\n        vs.delete(v);\n        if (!vs.size) {\n          g.delete(k);\n        }\n      }\n      if (g.has(v)) {\n        const ks = g.get(v);\n        ks.delete(k);\n        if (!ks.size) {\n          g.delete(v);\n        }\n      }\n    },\n    size: () => g.size,\n    has: (k) => {\n      if (g.has(k)) {\n        const vs = g.get(k);\n        // functions are truthy,\n        // this allows us to have optional edge checking via closure.\n        return (v) => new Set(vs).has(v);\n      }\n      return false;\n    },\n    // spread operator prevents mutation to graph internals\n    get: (x) => (g.has(x) ? new Set(g.get(x)) : undefined),\n    set: (k) => (v) => {\n      if (g.has(k)) {\n        g.get(k).add(v);\n      } else {\n        g.set(k, new Set([v]));\n      }\n      if (g.has(v)) {\n        g.get(v).add(k);\n      } else {\n        g.set(v, new Set([k]));\n      }\n    },\n    nodes: () => new Set(g.keys()),\n    edges: () => {\n      const e = new Map();\n      g.forEach(([k, vs]) => vs.forEach((v) => e.set(k, v)));\n      return e;\n    },\n    tidy: () => {\n      g.entries().map(([k, vs]) => {\n        loop((v) => {\n          if (g.has(v)) {\n            if (!g.get(v).has(k)) {\n              err(\"non-bidirectional | exists in set, not in map: \", k);\n            }\n          } else {\n            err(\"non-bidirectional | exists in map, not in set: \", v);\n          }\n        })(vs);\n      });\n    },\n  };\n};\n\nexport { Graph };\n", "const loop = (fn) => (xs) => {\n  for (const x of xs) {\n    fn(x);\n  }\n};\nconst log = (x) => (console.log(x), x);\nconst QSA = (sel, el = document) => el.querySelectorAll(sel);\nconst asEl = (node) => (node.tagName ? node : node.parentElement);\nconst invoke = (fn, ...args) => fn(...args);\nconst documentPositionComparator = (a, b) => {\n  if (a === b) {\n    return 0;\n  }\n  var position = a.compareDocumentPosition(b);\n  if (\n    position & Node.DOCUMENT_POSITION_FOLLOWING ||\n    position & Node.DOCUMENT_POSITION_CONTAINED_BY\n  ) {\n    return -1;\n  } else if (\n    position & Node.DOCUMENT_POSITION_PRECEDING ||\n    position & Node.DOCUMENT_POSITION_CONTAINS\n  ) {\n    return 1;\n  } else {\n    return 0;\n  }\n};\nconst sortEls = (els) =>\n  (\"sort\" in els ? els : [...els]).sort(documentPositionComparator);\n\nexport { loop, log, QSA, asEl, sortEls, invoke };\n", "import { Graph } from \"./graph.js\";\nimport { log, loop, QSA, asEl, sortEls, invoke } from \"./utils.js\";\n\nconst onDom = (c) => {\n  // STATE\n  const config = {\n    root: c.root || document,\n    scheduleInit:\n      c.scheduleInit ||\n      ((fn) =>\n        addEventListener(\"DOMContentLoaded\", fn, {\n          once: true,\n        })),\n    scheduleQueue: c.scheduleQueue || ((fn) => fn()),\n  };\n  const observerConfig = {\n    attributes: true,\n    attributeOldValue: true,\n    childList: true,\n    subtree: true,\n  };\n  const state = {\n    // state\n    graph: Graph(), // all known relevant elements\n    match: new Set(), // needs to rematch plugins because element moved/mutated\n    query: new Set(), // needs to query\n    queue: new Set(), // contents updated\n    after: new Set(), // contents updated\n    plugins: new Set(c.plugins || []),\n    active: new Set(),\n    allSelect: \"*\",\n  };\n  // SETUP\n  const maybeActivatePlugin = (p) => {\n    let init;\n    if (p.media) {\n      init = matchMedia(p.media);\n    }\n    const checkRelevance = (when) => {\n      if (when.matches) {\n        state.active.add(p);\n        initPlugin(p);\n      } else {\n        if (state.graph.has(p)) {\n          state.graph.get(p).forEach(p.update);\n          state.graph.delete(p);\n          state.active.delete(p);\n        }\n      }\n    };\n    if (init) {\n      checkRelevance(init);\n      // ideally, this would be responsive.\n      // yet it isn't, and I don't wanna debug tonight.\n      init.addEventListener(\"changes\", checkRelevance);\n    } else {\n      state.active.add(p);\n      initPlugin(p);\n    }\n  };\n  const refreshAllSelect = () => {\n    state.allSelect = [...state.active].map((p) => p.select).join();\n  };\n  const clearRuntime = () => {\n    state.match.clear();\n    state.query.clear();\n    state.queue.clear();\n    state.after.clear();\n  };\n  const deleteFromGraph = (el) => () => {\n    if (!el.isConnected) {\n      loop((x) => state.graph.delete(x))(QSA(\"*\", el));\n      state.graph.delete(el);\n    }\n  };\n  const runUpdate = (el) => {\n    if (!state.graph.has(el)) return console.log(el, \"doesn't have a plugin\");\n    const plugins = state.graph.get(el);\n    loop((p) => p.update(el))(plugins);\n    // remove element from graph if it doesn't exist after the update.\n    state.after.add(deleteFromGraph(el));\n  };\n  const queueAncestors = ({ parentElement }) => {\n    if (!parentElement || state.queue.has(parentElement)) return;\n    queueAncestors(parentElement);\n    if (state.graph.has(parentElement)) {\n      state.queue.add(parentElement);\n    }\n  };\n  const maybeEdge = (el) => (p) => {\n    const matches = el.matches(p.select);\n    const hasEdge = state.graph.has(p, el);\n    if (hasEdge !== matches) {\n      matches\n        ? state.graph.set(p)(el)\n        : // allows non-matching elements to run one last time to clean-up.\n          state.after.add(() => {\n            state.graph.remove(p)(el);\n          });\n    }\n    if (hasEdge || matches) {\n      state.queue.add(el);\n    }\n  };\n  const matchElement = (el) => [...state.active].map(maybeEdge(el));\n  const queryElement = (el) => {\n    // self matches\n    (el.matches(state.allSelect) || state.graph.has(el)) && state.match.add(el);\n    // child matches\n    // finds current matches\n    loop((x) => state.match.add(x))(QSA(state.allSelect, el));\n    // finds previous matches\n    loop((x) => state.graph.has(x) && state.match.add(x))(QSA(\"*\", el));\n  };\n  const onQueue = () => {\n    loop(queryElement)(state.query);\n    loop(matchElement)(state.match);\n    loop(queueAncestors)(state.queue);\n    loop(runUpdate)(sortEls(state.queue));\n    loop(invoke)(state.after);\n    clearRuntime();\n  };\n  const addElementsToQuery = loop((n) => {\n    const el = asEl(n);\n    el && state.query.add(el);\n  });\n  const onMutationRecord = (mr) => {\n    mr.type === \"attributes\" && state.match.add(asEl(mr.target));\n    mr.addedNodes.length && addElementsToQuery(mr.addedNodes);\n    mr.removedNodes.length && addElementsToQuery(mr.removedNodes);\n    state.match.add(asEl(mr.target));\n  };\n  const onMutationRecords = (mrs) => {\n    loop(onMutationRecord)(mrs);\n    config.scheduleQueue(onQueue);\n  };\n  const observer = new MutationObserver(onMutationRecords);\n  const initElement = (p) => (el) => {\n    state.graph.set(p)(el);\n    p.update(el);\n  };\n  const initPlugin = (p) => {\n    refreshAllSelect();\n    loop(initElement(p))(QSA(p.select, config.root));\n  };\n\n  // Initialize\n  config.scheduleInit(() => {\n    state.plugins.forEach(maybeActivatePlugin);\n    observer.observe(config.root, observerConfig);\n  });\n\n  // API\n  const MAIN_FUNCTION = (x) => [...state.graph.get(x)];\n  const METHODS = {\n    add: (p) => {\n      state.plugins.add(p);\n      maybeActivatePlugin(p);\n    },\n    clear: () => {\n      clearRuntime();\n      state.graph.clear();\n    },\n    delete: (p) => {\n      state.plugins.delete(p);\n      state.graph.delete(p);\n    },\n    has: (p) => state.graph.has(p),\n    active: () => [...state.active],\n  };\n  const API = Object.assign(MAIN_FUNCTION, METHODS);\n\n  return c.debug ? Object.assign(API, { debug: state }) : API;\n};\n\nexport { onDom };\n", "// console.log(\"hello\");\n\n// 4 call structure\n// 1) establish the timing strategy\n// 2) wrap the function with the desired timing\n// 3) provide the arguments to begin the timing\n// 4) returns a closure to cancel the call, or replace the debounce FN and Argument\nconst extendFunction = (fn, obj) =>\n  new Proxy(fn, {\n    get: (target, prop) => obj[prop].bind(obj),\n    apply: function (target, ctx, args) {\n      return fn(...args);\n    },\n  });\n\n// Timing a bunch of jobs.\n// the shape kinda looks like this\n// {[root]: {[sequence]: {[timing]: {[fn]: [args]}}}}\nfunction sequencer(sequence) {\n  if (!this.rootMap) {\n    this.rootMap = new Map();\n  }\n  const rootMap = this.rootMap;\n  if (!rootMap.has(sequence)) rootMap.set(sequence, new Map());\n  const seqMap = rootMap.get(sequence);\n  const upsertTiming = (timing) => {\n    if (!seqMap.has(timing)) seqMap.set(timing, new Map());\n    const timingMap = seqMap.get(timing);\n    const upsertFn = (fn, argsUpserter) => {\n      const fnMap = rootMap.get(timing);\n      const upsertArgs = (...args) => {\n        const upsertedArgs = fnMap.has(fn)\n          ? argsUpserter(fnMap.get(fn), args)\n          : args;\n        fnMap.set(fn, upsertedArgs);\n      };\n      sequence(timing, fnMap);\n      return extendFunction(upsertArgs, fnMap);\n    };\n    return extendFunction(upsertFn, timingMap);\n  };\n  return extendFunction(upsertTiming, seqMap);\n}\n\nconst batchMap = (timing, fnMap) =>\n  timing(() => {\n    const callFn = ([fn, args]) => fn(...args);\n    fnMap.entries().forEach(callFn);\n    fnMap.clear();\n  });\nconst batch = sequencer(batchMap);\n\nconst recurMap = (timing, fnMap) => {\n  timing(() => {\n    const [fn, args] = fnMap.entries().next().value;\n    fn(...args);\n    fnMap.delete(fn);\n    recurMap(timing, fnMap);\n  });\n};\nconst recur = sequencer(recurMap);\n\n// Timing individual Jobs\n\nconst orca = (timing) => (fn) => {\n  const me = { fn, canceled: false };\n  me.cancel = () => (me.canceled = true);\n  // API to set min time between consecutive fn calls\n  me.throttler = (throttleTimer) => {\n    me.throttle = () => {\n      // don't reset the running throttle\n      if (me.throttled) return;\n      throttleTimer(() => (me.throttled = false))();\n      me.throttled = true;\n    };\n  };\n\n  return function (...args) {\n    me.args = args;\n    // this only puts a date if this has been previously declared as true.\n    if (me.debounce) {\n      me.debounce = Date.now();\n    }\n    me.callback = () => me.fn(...me.args);\n    const filterCall = (_debounce, ok) =>\n      [\n        me.canceled,\n        me.throttled,\n        // only compare debounce times between init and call if debounce is true\n        // if init and call aren't equal; that means there has been a call between init and call,\n        // so we should early eject\n        me.debounce && me.debounce !== _debounce,\n        () => ok(me.callback()),\n      ].find((x) => x);\n    const resolve = (_debounce) => (ok) => {\n      // only pass timing the num of arguments it wants. (fn.length == argCount)\n      const timingArgs = [filterCall(_debounce, ok), me];\n      // console.log(timingArgs)\n      timingArgs.length = timing.length;\n      timing(...timingArgs);\n    };\n    // queues throttling for subsequent calls\n    if (me.throttle) {\n      me.throttle();\n    }\n    const resultPromise = new Promise(resolve(me.debounce));\n    return extendFunction(this, Object.assign(resultPromise, me));\n  };\n};\n\nconst sync = orca((fn) => fn);\nconst then = orca(queueMicrotask);\nconst task = orca(setTimeout);\nconst tick = orca(requestAnimationFrame);\nconst next = orca((cb) =>\n  requestAnimationFrame(() => requestAnimationFrame(cb))\n);\nconst idle = orca(requestIdleCallback);\n\nconst wait = (ms = 0) => orca((fn) => setTimeout(fn, ms));\nconst once = orca((cb, me) => {\n  cb();\n  me.cancel();\n});\n\nexport {\n  extendFunction,\n  batch,\n  recur,\n  orca,\n  sync,\n  then,\n  task,\n  tick,\n  next,\n  idle,\n  wait,\n  once,\n};\n// orca is a way to easily tap into the event loop!\n// wrap functions with\n// Object.entries({\n//   wait100: wait(100),\n//   once,\n//   twice: once,\n//   wait0: wait(0),\n//   idle,\n//   tick,\n//   wait10: wait(10),\n//   next,\n//   task,\n//   then,\n//   sync\n// }).forEach(([name, fn]) => fn(console.log)(name));\n\n// console.log(\"end \");\n"],
  "mappings": "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",
  "names": []
}
