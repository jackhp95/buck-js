var y=(s=[])=>{let c=(...e)=>console.warn(...e),n=new Map(s);return{clear:()=>n.clear(),delete:e=>{if(n.has(e)){let o=n.get(e);return o.forEach(a=>{let d=n.get(a);d.delete(e),d.size||n.delete(a)}),n.delete(e),o}},remove:e=>o=>{if(n.has(e)){let a=n.get(e);a.delete(o),a.size||n.delete(e)}if(n.has(o)){let a=n.get(o);a.delete(e),a.size||n.delete(o)}},size:()=>n.size,has:e=>{if(n.has(e)){let o=n.get(e);return a=>new Set(o).has(a)}return!1},get:e=>n.has(e)?new Set(n.get(e)):void 0,set:e=>o=>{n.has(e)?n.get(e).add(o):n.set(e,new Set([o])),n.has(o)?n.get(o).add(e):n.set(o,new Set([e]))},nodes:()=>new Set(n.keys()),edges:()=>{let e=[];return n.forEach((o,a)=>o.forEach(d=>e.push([a,d]))),e},tidy:()=>{n.entries().map(([e,o])=>{loop(a=>{n.has(a)?n.get(a).has(e)||c("non-bidirectional | exists in set, not in map: ",e):c("non-bidirectional | exists in map, not in set: ",a)})(o)})}}};var i=s=>c=>{for(let n of c)s(n)};var g=(s,c=document)=>c.querySelectorAll(s);var h=s=>s.tagName?s:s.parentElement,O=(s,...c)=>s(...c);var M=(s,c)=>{if(s===c)return 0;var n=s.compareDocumentPosition(c);return n&Node.DOCUMENT_POSITION_FOLLOWING||n&Node.DOCUMENT_POSITION_CONTAINED_BY?-1:n&Node.DOCUMENT_POSITION_PRECEDING||n&Node.DOCUMENT_POSITION_CONTAINS?1:0},b=s=>("sort"in s?s:[...s]).sort(M);var U=async s=>{let c={root:s.root||document,scheduleInit:s.scheduleInit||(t=>addEventListener("DOMContentLoaded",t,{once:!0})),scheduleQueue:s.scheduleQueue||(t=>t())},n={attributes:!0,attributeOldValue:!0,childList:!0,subtree:!0},e={graph:y(),match:new Set,query:new Set,queue:new Set,after:new Set,plugins:new Set(s.plugins||[]),allSelect:""},o=()=>{e.allSelect=[...e.plugins].map(t=>t.select).join()},a=()=>{e.match.clear(),e.query.clear(),e.queue.clear(),e.after.clear()},d=t=>()=>{t.isConnected||(i(r=>e.graph.delete(r))(g("*",t)),e.graph.delete(t))},S=t=>{let r=e.graph.get(t);!r||(i(l=>l.update(t))(r),e.after.add(d(t)))},f=({parentElement:t})=>{!t||e.queue.has(t)||(f(t),e.graph.has(t)&&e.queue.add(t))},N=t=>r=>{let l=t.matches(r.select),u=e.graph.has(r,t);u!==l&&(l?e.graph.set(r)(t):e.after.add(()=>{e.graph.remove(r)(t)})),(u||l)&&e.queue.add(t)},E=t=>[...e.plugins].map(N(t)),I=t=>{(t.matches(e.allSelect)||e.graph.has(t))&&e.match.add(t),i(r=>e.match.add(r))(g(e.allSelect,t)),i(r=>e.graph.has(r)&&e.match.add(r))(g("*",t))},P=()=>{i(I)(e.query),i(E)(e.match),i(f)(e.queue),console.log(e.queue),i(S)(b(e.queue)),i(O)(e.after),a()},p=i(t=>{let r=h(t);r&&e.query.add(r)}),T=t=>{t.type==="attributes"&&(e.match.add(h(t.target)),t.attributeName in Object.getPrototypeOf(t.target)||delete t.target[t.attributeName]),t.addedNodes.length&&p(t.addedNodes),t.removedNodes.length&&p(t.removedNodes),e.match.add(h(t.target))},w=t=>{!e.allSelect||(i(T)(t),c.scheduleQueue(P))},j=new MutationObserver(w),q=t=>r=>{e.graph.set(t)(r),t.update(r)},m=t=>t.select&&i(q(t))(g(t.select,c.root)),A=()=>{let l=Object.assign(u=>[...e.graph.get(u)],{add:u=>{e.plugins.add(u),m(u)},clear:()=>{a(),e.graph.clear()},delete:u=>{e.plugins.delete(u),e.graph.delete(u)},has:u=>e.graph.has(u)});return s.debug?Object.assign(l,{debug:e}):l},C=async t=>{i(m)(e.plugins),o(),j.observe(c.root,n),t(A())};return new Promise(t=>c.scheduleInit(()=>C(t)))};export{U as onDom};
//# sourceMappingURL=ondom.js.map
