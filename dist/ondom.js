var N=(o=[])=>{let c=(...e)=>console.warn(...e),s=new Map(o);return{clear:()=>s.clear(),delete:e=>{if(s.has(e)){let n=s.get(e);return n.forEach(a=>{let l=s.get(a);l.delete(e),l.size||s.delete(a)}),s.delete(e),n}},remove:e=>n=>{if(s.has(e)){let a=s.get(e);a.delete(n),a.size||s.delete(e)}if(s.has(n)){let a=s.get(n);a.delete(e),a.size||s.delete(n)}},size:()=>s.size,has:e=>{if(s.has(e)){let n=s.get(e);return a=>new Set(n).has(a)}return!1},get:e=>s.has(e)?new Set(s.get(e)):void 0,set:e=>n=>{s.has(e)?s.get(e).add(n):s.set(e,new Set([n])),s.has(n)?s.get(n).add(e):s.set(n,new Set([e]))},nodes:()=>new Set(s.keys()),edges:()=>{let e=[];return s.forEach((n,a)=>n.forEach(l=>e.push([a,l]))),e},tidy:()=>{s.entries().map(([e,n])=>{loop(a=>{s.has(a)?s.get(a).has(e)||c("non-bidirectional | exists in set, not in map: ",e):c("non-bidirectional | exists in map, not in set: ",a)})(n)})}}};var u=o=>c=>{for(let s of c)o(s)};var h=(o,c=document)=>c.querySelectorAll(o),g=o=>o.tagName?o:o.parentElement,O=(o,...c)=>o(...c);var P=(o,c)=>{if(o===c)return 0;var s=o.compareDocumentPosition(c);return s&Node.DOCUMENT_POSITION_FOLLOWING||s&Node.DOCUMENT_POSITION_CONTAINED_BY?-1:s&Node.DOCUMENT_POSITION_PRECEDING||s&Node.DOCUMENT_POSITION_CONTAINS?1:0},S=o=>("sort"in o?o:[...o]).sort(P);var z=async o=>{let c={root:o.root||document,scheduleInit:o.scheduleInit||(t=>addEventListener("DOMContentLoaded",t,{once:!0})),scheduleQueue:o.scheduleQueue||(t=>t())},s={attributes:!0,attributeOldValue:!0,childList:!0,subtree:!0},e={graph:N(),match:new Set,query:new Set,queue:new Set,after:new Set,plugins:new Set(o.plugins||[]),allSelect:"*"},n=()=>{e.allSelect=[...e.plugins].map(t=>t.select).join()},a=()=>{e.match.clear(),e.query.clear(),e.queue.clear(),e.after.clear()},l=t=>()=>{t.isConnected||(u(r=>e.graph.delete(r))(h("*",t)),e.graph.delete(t))},E=t=>{let r=e.graph.get(t);!r||(u(i=>i.update(t))(r),e.after.add(l(t)))},p=({parentElement:t})=>{!t||e.queue.has(t)||(p(t),e.graph.has(t)&&e.queue.add(t))},I=t=>r=>{let i=t.matches(r.select),d=e.graph.has(r,t);d!==i&&(i?e.graph.set(r)(t):e.after.add(()=>{e.graph.remove(r)(t)})),(d||i)&&e.queue.add(t)},y=t=>[...e.plugins].map(I(t)),b=t=>{(t.matches(e.allSelect)||e.graph.has(t))&&e.match.add(t),u(r=>e.match.add(r))(h(e.allSelect,t)),u(r=>e.graph.has(r)&&e.match.add(r))(h("*",t))},T=()=>{u(b)(e.query),u(y)(e.match),u(p)(e.queue),u(E)(S(e.queue)),u(O)(e.after),a()},f=u(t=>{let r=g(t);r&&e.query.add(r)}),w=t=>{t.type==="attributes"&&e.match.add(g(t.target)),t.addedNodes.length&&f(t.addedNodes),t.removedNodes.length&&f(t.removedNodes),e.match.add(g(t.target))},q=t=>{u(w)(t),c.scheduleQueue(T)},M=new MutationObserver(q),C=t=>r=>{e.graph.set(t)(r),t.update(r)},m=t=>u(C(t))(h(t.select,c.root)),D=()=>{let i=Object.assign(d=>[...e.graph.get(d)],{add:d=>{e.plugins.add(d),m(d)},clear:()=>{a(),e.graph.clear()},delete:d=>{e.plugins.delete(d),e.graph.delete(d)},has:d=>e.graph.has(d)});return o.debug?Object.assign(i,{debug:e}):i},A=async t=>{u(m)(e.plugins),n(),M.observe(c.root,s),t(D())};return new Promise(t=>c.scheduleInit(()=>A(t)))};export{z as onDom};
//# sourceMappingURL=ondom.js.map
