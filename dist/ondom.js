var O=(s=[])=>{let o=(...e)=>console.warn(...e),n=new Map(s);return{clear:()=>n.clear(),delete:e=>{if(n.has(e)){let r=n.get(e);return r.forEach(c=>{let d=n.get(c);d.delete(e),d.size||n.delete(c)}),n.delete(e),r}},remove:e=>r=>{if(n.has(e)){let c=n.get(e);c.delete(r),c.size||n.delete(e)}if(n.has(r)){let c=n.get(r);c.delete(e),c.size||n.delete(r)}},size:()=>n.size,has:e=>{if(n.has(e)){let r=n.get(e);return c=>new Set(r).has(c)}return!1},get:e=>n.has(e)?new Set(n.get(e)):void 0,set:e=>r=>{n.has(e)?n.get(e).add(r):n.set(e,new Set([r])),n.has(r)?n.get(r).add(e):n.set(r,new Set([e]))},nodes:()=>new Set(n.keys()),edges:()=>{let e=[];return n.forEach((r,c)=>r.forEach(d=>e.push([c,d]))),e},tidy:()=>{n.entries().map(([e,r])=>{loop(c=>{n.has(c)?n.get(c).has(e)||o("non-bidirectional | exists in set, not in map: ",e):o("non-bidirectional | exists in map, not in set: ",c)})(r)})}}};var i=s=>o=>{for(let n of o)s(n)};var g=(s,o=document)=>o.querySelectorAll(s);var h=s=>s.tagName?s:s.parentElement,y=(s,...o)=>s(...o),_=()=>{};var D=(s,o=_)=>(...n)=>{try{return s(...n)}catch(e){return o(e,...n)}};var v=(s,o)=>{if(s===o)return 0;var n=s.compareDocumentPosition(o);return n&Node.DOCUMENT_POSITION_FOLLOWING||n&Node.DOCUMENT_POSITION_CONTAINED_BY?-1:n&Node.DOCUMENT_POSITION_PRECEDING||n&Node.DOCUMENT_POSITION_CONTAINS?1:0},S=s=>("sort"in s?s:[...s]).sort(v),$={1:s=>{let o={};return i(n=>{o[n.name]=n.value})(s.attributes),o},2:(s,o)=>s.getAttribute(o),3:(s,o,n)=>s.setAttribute(o,n)},F=(...s)=>$[s.length](s),p=(s,...o)=>(n,...e)=>{if(!(s in n)){let r=Function(...o,n.getAttribute(s)).bind(n);n[s]=r}return n[s](...e)},Q=(s,o)=>n=>{if(!(s in n)){let e=n.getAttribute(s),r=/^[\.\[]/.test(e)?e:"."+e;n[s]=Function("maybe","obj",`return maybe((...a) => {
          if (a.length) {
            const [value] = a;
            obj${r} = value;
          }
          return obj${r};
        });`)(D,o)}return n[s]},U={event:s=>o=>p(s,"event")(o.target,o),entry:s=>o=>p(s,"entry")(o.target,o),js:p,resolve:Q},z=Object.assign(F,U);var H=async s=>{let o={root:s.root||document,scheduleInit:s.scheduleInit||(t=>addEventListener("DOMContentLoaded",t,{once:!0})),scheduleQueue:s.scheduleQueue||(t=>t())},n={attributes:!0,attributeOldValue:!0,childList:!0,subtree:!0},e={graph:O(),match:new Set,query:new Set,queue:new Set,after:new Set,plugins:new Set(s.plugins||[]),allSelect:""},r=()=>{e.allSelect=[...e.plugins].map(t=>t.select).join()},c=()=>{e.match.clear(),e.query.clear(),e.queue.clear(),e.after.clear()},d=t=>()=>{t.isConnected||(i(a=>e.graph.delete(a))(g("*",t)),e.graph.delete(t))},N=t=>{let a=e.graph.get(t);!a||(i(l=>l.update(t))(a),e.after.add(d(t)))},f=({parentElement:t})=>{!t||e.queue.has(t)||(f(t),e.graph.has(t)&&e.queue.add(t))},E=t=>a=>{let l=t.matches(a.select),u=e.graph.has(a,t);u!==l&&(l?e.graph.set(a)(t):e.after.add(()=>{e.graph.remove(a)(t)})),(u||l)&&e.queue.add(t)},I=t=>[...e.plugins].map(E(t)),w=t=>{(t.matches(e.allSelect)||e.graph.has(t))&&e.match.add(t),i(a=>e.match.add(a))(g(e.allSelect,t)),i(a=>e.graph.has(a)&&e.match.add(a))(g("*",t))},A=()=>{i(w)(e.query),i(I)(e.match),i(f)(e.queue),i(N)(S(e.queue)),i(y)(e.after),c()},m=i(t=>{let a=h(t);a&&e.query.add(a)}),C=t=>{t.type==="attributes"&&(e.match.add(h(t.target)),t.attributeName in Object.getPrototypeOf(t.target)||delete t.target[t.attributeName]),t.addedNodes.length&&m(t.addedNodes),t.removedNodes.length&&m(t.removedNodes),e.match.add(h(t.target))},P=t=>{!e.allSelect||(i(C)(t),o.scheduleQueue(A))},T=new MutationObserver(P),M=t=>a=>{e.graph.set(t)(a),t.update(a)},b=t=>t.select&&i(M(t))(g(t.select,o.root)),q=()=>{let l=Object.assign(u=>[...e.graph.get(u)],{add:u=>{e.plugins.add(u),b(u)},clear:()=>{c(),e.graph.clear()},delete:u=>{e.plugins.delete(u),e.graph.delete(u)},has:u=>e.graph.has(u)});return s.debug?Object.assign(l,{debug:e}):l},j=async t=>{i(b)(e.plugins),r(),T.observe(o.root,n),t(q())};return new Promise(t=>o.scheduleInit(()=>j(t)))};export{H as onDom};
//# sourceMappingURL=ondom.js.map
