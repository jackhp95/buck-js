{
  "version": 3,
  "sources": ["../src/orca.js"],
  "sourcesContent": ["// console.log(\"hello\");\n\n// 4 call structure\n// 1) establish the timing strategy\n// 2) wrap the function with the desired timing\n// 3) provide the arguments to begin the timing\n// 4) returns a closure to cancel the call, or replace the debounce FN and Argument\nconst extendFunction = (fn, obj) =>\n  new Proxy(fn, {\n    get: (target, prop) => obj[prop].bind(obj),\n    apply: function (target, ctx, args) {\n      return fn(...args);\n    },\n  });\n\n// Timing a bunch of jobs.\n// the shape kinda looks like this\n// {[root]: {[sequence]: {[timing]: {[fn]: [args]}}}}\nfunction sequencer(sequence) {\n  if (!this.rootMap) {\n    this.rootMap = new Map();\n  }\n  const rootMap = this.rootMap;\n  if (!rootMap.has(sequence)) rootMap.set(sequence, new Map());\n  const seqMap = rootMap.get(sequence);\n  const upsertTiming = (timing) => {\n    if (!seqMap.has(timing)) seqMap.set(timing, new Map());\n    const timingMap = seqMap.get(timing);\n    const upsertFn = (fn, argsUpserter) => {\n      const fnMap = rootMap.get(timing);\n      const upsertArgs = (...args) => {\n        const upsertedArgs = fnMap.has(fn)\n          ? argsUpserter(fnMap.get(fn), args)\n          : args;\n        fnMap.set(fn, upsertedArgs);\n      };\n      sequence(timing, fnMap);\n      return extendFunction(upsertArgs, fnMap);\n    };\n    return extendFunction(upsertFn, timingMap);\n  };\n  return extendFunction(upsertTiming, seqMap);\n}\n\nconst batchMap = (timing, fnMap) =>\n  timing(() => {\n    const callFn = ([fn, args]) => fn(...args);\n    fnMap.entries().forEach(callFn);\n    fnMap.clear();\n  });\nconst batch = sequencer(batchMap);\n\nconst recurMap = (timing, fnMap) => {\n  timing(() => {\n    const [fn, args] = fnMap.entries().next().value;\n    fn(...args);\n    fnMap.delete(fn);\n    recurMap(timing, fnMap);\n  });\n};\nconst recur = sequencer(recurMap);\n\n// Timing individual Jobs\n\nconst orca = (timing) => (fn) => {\n  const me = { fn, canceled: false };\n  me.cancel = () => (me.canceled = true);\n  // API to set min time between consecutive fn calls\n  me.throttler = (throttleTimer) => {\n    me.throttle = () => {\n      // don't reset the running throttle\n      if (me.throttled) return;\n      throttleTimer(() => (me.throttled = false))();\n      me.throttled = true;\n    };\n  };\n\n  return function (...args) {\n    me.args = args;\n    // this only puts a date if this has been previously declared as true.\n    if (me.debounce) {\n      me.debounce = Date.now();\n    }\n    me.callback = () => me.fn(...me.args);\n    const filterCall = (_debounce, ok) =>\n      [\n        me.canceled,\n        me.throttled,\n        // only compare debounce times between init and call if debounce is true\n        // if init and call aren't equal; that means there has been a call between init and call,\n        // so we should early eject\n        me.debounce && me.debounce !== _debounce,\n        () => ok(me.callback()),\n      ].find((x) => x);\n    const resolve = (_debounce) => (ok) => {\n      // only pass timing the num of arguments it wants. (fn.length == argCount)\n      const timingArgs = [filterCall(_debounce, ok), me];\n      // console.log(timingArgs)\n      timingArgs.length = timing.length;\n      timing(...timingArgs);\n    };\n    // queues throttling for subsequent calls\n    if (me.throttle) {\n      me.throttle();\n    }\n    const resultPromise = new Promise(resolve(me.debounce));\n    return extendFunction(this, Object.assign(resultPromise, me));\n  };\n};\n\nconst sync = orca((fn) => fn);\nconst then = orca(queueMicrotask);\nconst task = orca(setTimeout);\nconst tick = orca(requestAnimationFrame);\nconst next = orca((cb) =>\n  requestAnimationFrame(() => requestAnimationFrame(cb))\n);\nconst idle = orca(requestIdleCallback);\n\nconst wait = (ms = 0) => orca((fn) => setTimeout(fn, ms));\nconst once = orca((cb, me) => {\n  cb();\n  me.cancel();\n});\n\nexport {\n  extendFunction,\n  batch,\n  recur,\n  orca,\n  sync,\n  then,\n  task,\n  tick,\n  next,\n  idle,\n  wait,\n  once,\n};\n// orca is a way to easily tap into the event loop!\n// wrap functions with\n// Object.entries({\n//   wait100: wait(100),\n//   once,\n//   twice: once,\n//   wait0: wait(0),\n//   idle,\n//   tick,\n//   wait10: wait(10),\n//   next,\n//   task,\n//   then,\n//   sync\n// }).forEach(([name, fn]) => fn(console.log)(name));\n\n// console.log(\"end \");\n"],
  "mappings": "AAOA,GAAM,GAAiB,CAAC,EAAI,IAC1B,GAAI,OAAM,EAAI,CACZ,IAAK,CAAC,EAAQ,IAAS,EAAI,GAAM,KAAK,GACtC,MAAO,SAAU,EAAQ,EAAK,EAAM,CAClC,MAAO,GAAG,GAAG,MAOnB,WAAmB,EAAU,CAC3B,AAAK,KAAK,SACR,MAAK,QAAU,GAAI,MAErB,GAAM,GAAU,KAAK,QACrB,AAAK,EAAQ,IAAI,IAAW,EAAQ,IAAI,EAAU,GAAI,MACtD,GAAM,GAAS,EAAQ,IAAI,GAiB3B,MAAO,GAhBc,AAAC,GAAW,CAC/B,AAAK,EAAO,IAAI,IAAS,EAAO,IAAI,EAAQ,GAAI,MAChD,GAAM,GAAY,EAAO,IAAI,GAY7B,MAAO,GAXU,CAAC,EAAI,IAAiB,CACrC,GAAM,GAAQ,EAAQ,IAAI,GACpB,EAAa,IAAI,IAAS,CAC9B,GAAM,GAAe,EAAM,IAAI,GAC3B,EAAa,EAAM,IAAI,GAAK,GAC5B,EACJ,EAAM,IAAI,EAAI,IAEhB,SAAS,EAAQ,GACV,EAAe,EAAY,IAEJ,IAEE,GAGtC,GAAM,GAAW,CAAC,EAAQ,IACxB,EAAO,IAAM,CACX,GAAM,GAAS,CAAC,CAAC,EAAI,KAAU,EAAG,GAAG,GACrC,EAAM,UAAU,QAAQ,GACxB,EAAM,UAEJ,EAAQ,EAAU,GAElB,EAAW,CAAC,EAAQ,IAAU,CAClC,EAAO,IAAM,CACX,GAAM,CAAC,EAAI,GAAQ,EAAM,UAAU,OAAO,MAC1C,EAAG,GAAG,GACN,EAAM,OAAO,GACb,EAAS,EAAQ,MAGf,EAAQ,EAAU,GAIlB,EAAO,AAAC,GAAW,AAAC,GAAO,CAC/B,GAAM,GAAK,CAAE,KAAI,SAAU,IAC3B,SAAG,OAAS,IAAO,EAAG,SAAW,GAEjC,EAAG,UAAY,AAAC,GAAkB,CAChC,EAAG,SAAW,IAAM,CAElB,AAAI,EAAG,WACP,GAAc,IAAO,EAAG,UAAY,MACpC,EAAG,UAAY,MAIZ,YAAa,EAAM,CACxB,EAAG,KAAO,EAEN,EAAG,UACL,GAAG,SAAW,KAAK,OAErB,EAAG,SAAW,IAAM,EAAG,GAAG,GAAG,EAAG,MAChC,GAAM,GAAa,CAAC,EAAW,IAC7B,CACE,EAAG,SACH,EAAG,UAIH,EAAG,UAAY,EAAG,WAAa,EAC/B,IAAM,EAAG,EAAG,aACZ,KAAK,AAAC,GAAM,GACV,EAAU,AAAC,GAAc,AAAC,GAAO,CAErC,GAAM,GAAa,CAAC,EAAW,EAAW,GAAK,GAE/C,EAAW,OAAS,EAAO,OAC3B,EAAO,GAAG,IAGZ,AAAI,EAAG,UACL,EAAG,WAEL,GAAM,GAAgB,GAAI,SAAQ,EAAQ,EAAG,WAC7C,MAAO,GAAe,KAAM,OAAO,OAAO,EAAe,MAIvD,EAAO,EAAK,AAAC,GAAO,GACpB,EAAO,EAAK,gBACZ,EAAO,EAAK,YACZ,EAAO,EAAK,uBACZ,EAAO,EAAK,AAAC,GACjB,sBAAsB,IAAM,sBAAsB,KAE9C,EAAO,EAAK,qBAEZ,EAAO,CAAC,EAAK,IAAM,EAAK,AAAC,GAAO,WAAW,EAAI,IAC/C,EAAO,EAAK,CAAC,EAAI,IAAO,CAC5B,IACA,EAAG",
  "names": []
}
